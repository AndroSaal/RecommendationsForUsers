### Система рекомендаций для пользователей

#### Используемые технологии

#### *Контейнеры*
* Схема: ![Схема](schema.png)

Каждый сервис (`User`, `Recommendation`, `Analytics`, `Product`) поднимается в собственном контейнере, для каждого предусмотрена БД, которая тоже поднимается в отдельном контейнере.
Также есть контейнеры с `kafka`, `zookeeper`, `redis`, они оркестрируются с помощью `docker compose`

#### *Подход*
Разработка велась `сверху - вниз` - сначала был написан swagger-файл (aka openapi v2.0), описывающий эндпойнты сервиса, затем разрабатывалась ER-диаграмма для реляционной базы данных, в которую сервис будет обращаться, после же писался код в стиле чистой архитектуры: у каждого слоя сервиса есть интерфейс и тип данных - структура, его имплементирующая, также есть интерфейсы для реляционной и key-value БД в структуре repository.

#### *Файловая структура*
На примере сервиса recommendation:
* Структура: ![Структура](struct.png)

#### *Тестирование*
Для того, чтобы протестировать систему, нужно, находясь в директории app, ввести команду `make test`, Она создаст среду для тестирования.
Далее в контейнере с сервисом, который нужно протестировать нужно также прописать `make test` (внутри контейнера через `exec`), эта цель запустит все имеющиеся в наличии тесты и сформирует файл с отчетом о покрытии.
Для того, чтобы посмотреть, какие строки кода не были покрыты, нужно, из домашней среды (там, где возможно просмотреть html-файлик (Не в контейнере)) запустить команду make check_coverage.
В случае с тестированием сервиса recommendation, после запуска команды make test внутри контейнера, нужно подождать около 5 секунд, пока тесты не завершаться: это связано с тем, что тестовому продюсеру нужно время для отправки сообщения...

#### *Объем*
![кол-во строк](stroki.png)

#### *ps*
Везде, где есть api предусмотрена валидация параметров и проверка корректности (не получится удалить несуществующий продукт, вернёт 404)
Более подробно о используемых библиотеках и фреймфорках можно почитать в README каждого сервиса